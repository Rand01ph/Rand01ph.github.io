<!DOCTYPE html>
<html><meta charset="utf-8"><meta name="generator" content="Hugo 0.64.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light only">
<meta name="supported-color-schemes" content="light only"><title>React从入门到放弃&nbsp;&ndash;&nbsp;9r0k Site</title><link rel="stylesheet" href="/css/core.min.51a3025999844727ed93a564c6ad1f52feacd7a37d6e517a9343ae018831afa9bca8d064689d586938cf8ca3a1446d1b.css" integrity="sha384-UaMCWZmERyftk6Vkxq0fUv6s16N9blF6k0OuAYgxr6m8qNBkaJ1YaTjPjKOhRG0b"><body>
<div class="base-body max-width"><section id="header" class="header max-body-width"><p><a class="home" href="/"><span class="site-name">9r0k Site</span></a></p></section><div id="content" class="flex-body max-body-width"><section class="article-header">
<h1>React从入门到放弃</h1>
<p class="article-date">2020-02-11</p>
</section>
<article class="markdown-body"><h2 id="react从入门到放弃">React从入门到放弃</h2>
<h3 id="component-组件">Component 组件</h3>
<p>React组件中用花括号包含的JS代码会被执行,然后执行结果被嵌入组件中
组件名称必须大写</p>
<p>由于root元素是必须的，但是如果每个都加上 <code>&lt;div&gt;&lt;/div&gt;</code> 可能导致额外的div层级，这时候可以使用 <code>&lt;&gt;&lt;/&gt;</code> 简写来规避这个问题，同时解决root元素的问题.</p>
<p>NB: 不要在组件中定义组件</p>
<p>NB: 所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。</p>
<h3 id="props">props</h3>
<p>表示组件的入参</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">Hello</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">props</span>) =&gt; {
  <span style="color:#66d9ef">return</span> (
	<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span><span style="color:#f92672">&gt;</span>
	  <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">p</span><span style="color:#f92672">&gt;</span><span style="color:#a6e22e">Hello</span> {<span style="color:#a6e22e">props</span>.<span style="color:#a6e22e">name</span>}<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/</span><span style="color:#960050;background-color:#1e0010">p</span><span style="color:#960050;background-color:#1e0010">&gt;</span>
	<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/</span><span style="color:#960050;background-color:#1e0010">d</span><span style="color:#960050;background-color:#1e0010">i</span><span style="color:#960050;background-color:#1e0010">v</span><span style="color:#960050;background-color:#1e0010">&gt;</span>
  )
}
</code></pre></div><p>props会被当做一个object传入组件,如果传入props的参数是通过JS执行后得到的，需要用花括号包裹。
最后传入props的是变量的值，和执行的结果。
所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。</p>
<h3 id="jsx">JSX</h3>
<p><a href="https://zh-hans.reactjs.org/docs/introducing-jsx.html">https://zh-hans.reactjs.org/docs/introducing-jsx.html</a>
JSX提供了一种类似HTML的标签语法用来表示组件内容，最后会被编译成JS代码，如果使用 <code>create-react-app</code> 创建的项目
是通过 <code>Babel</code> 进行编译的。</p>
<p>看起来很像一种模板语言。
在 JSX 语法中，你可以在大括号内放置任何有效的 JavaScript 表达式</p>
<p>由于JSX的&quot;XML-like&rdquo;,标记必须关闭。 <code>&lt;br /&gt;</code></p>
<h3 id="受控组件">受控组件</h3>
<p>在 HTML 中，表单元素（如<!-- raw HTML omitted -->、 <!-- raw HTML omitted --> 和 <!-- raw HTML omitted -->）之类的表单元素通常自己维护 state，并根据用户输入进行更新。
而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState()来更新。</p>
<p>input 不需要 event.preventDefault(), 因为它本身不像表单提交没有默认的行为</p>
<h3 id="hooks">Hooks</h3>
<h4 id="hooks的规则">Hooks的规则</h4>
<p><code>useState</code>, <code>useEffect</code> 不要在循环，条件表达式，或者任何不是定义组件的函数中调用.
必须保证hooks总是被固定的顺序被调用</p>
<h4 id="state-hooks">State-hooks</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">React</span>, { <span style="color:#a6e22e">useState</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;react&#39;</span>
</code></pre></div><p>在React中最好不要直接修改state本身,变更state一般通过给state赋值新的对象方式进行.
直接修改state本身会造成一些不易察觉的错误，比如对array类型的state使用push方法</p>
<h4 id="effect-hooks">Effect-hooks</h4>
<ul>
<li>useEffect 做了什么？</li>
</ul>
<pre><code>通过使用这个 Hook，你可以告诉 React 组件需要在渲染后执行某些操作。
React 会保存你传递的函数（我们将它称之为 “effect”），并且在执行 DOM 更新之后调用它。
某种意义上讲，effect 更像是渲染结果的一部分 —— 每个 effect “属于”一次特定的渲染。

```js
import React, { useState, useEffect } from 'react';

useEffect(() =&gt; {
    document.title = `You clicked ${count} times`;
  });
```
</code></pre>
<ul>
<li>为什么在组件内部调用 useEffect？</li>
</ul>
<pre><code>将 useEffect 放在组件内部让我们可以在 effect 中直接访问 count state 变量（或其他 props）。
</code></pre>
<ul>
<li>useEffect 会在每次渲染后都执行吗？</li>
</ul>
<pre><code>是的，默认情况下，它在第一次渲染之后和每次更新之后都会执行。
</code></pre>
<ul>
<li>为什么要在 effect 中返回一个函数？</li>
</ul>
<pre><code>这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。
如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。
</code></pre>
<ul>
<li>React 何时清除 effect？</li>
</ul>
<pre><code>React 会在组件卸载的时候执行清除操作。
正如之前学到的，effect 在每次渲染的时候都会执行。
这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除。
</code></pre>
<ul>
<li>如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行）</li>
</ul>
<pre><code>可以传递一个空数组（[]）作为第二个参数。这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行。这并不属于特殊情况 —— 它依然遵循依赖数组的工作方式。
</code></pre>
<h3 id="条件渲染">条件渲染</h3>
<p><a href="https://zh-hans.reactjs.org/docs/conditional-rendering.html">https://zh-hans.reactjs.org/docs/conditional-rendering.html</a></p>
</article><section class="article-labels"><a class="article-category li" href=/categories/javascript/><span class="hashtag">#</span>javascript</a><a class="article-tag li" href=/tags/javascript/><span class="hashtag">#</span>javascript</a><a class="article-tag li" href=/tags/react/><span class="hashtag">#</span>react</a></section><section class="article-navigation"><p><a class="link" href="/blog/%E7%8E%B0%E4%BB%A3%E5%8C%96javascript%E6%8B%BE%E9%81%97/"><span class="li"></span>现代化javascript拾遗</a class="link"></p></section></div><section id="footer" class="footer max-body-width"><p>9r0k Site</p>
<p><span>Powered by </span><a href="https://gohugo.io">Hugo</a><span> and the </span><a href="https://themes.gohugo.io/hugo-notepadium/">Notepadium</a></p>
</section></div>
</body>
</html>